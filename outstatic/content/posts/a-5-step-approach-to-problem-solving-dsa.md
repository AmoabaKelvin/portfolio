---
title: 'A 5-Step Approach to Problem Solving (DSA)'
seoTitle: 'A 5-Step Approach to Problem Solving (DSA)'
datePublished: Sat Nov 18 2023 07:02:34 GMT+0000 (Coordinated Universal Time)
cuid: clp3pc0rq000l0ak2celtf039
slug: a-5-step-approach-to-problem-solving-dsa
cover: https://cdn.hashnode.com/res/hashnode/image/stock/unsplash/DnXqvmS0eXM/upload/878e2dab7224742cd552014716babee7.jpeg
tags: tutorial, algorithms, data-structures, beginners
status: 'published'
author:
  picture: ''
---

When starting to practice the data structures and algorithms you've learned on platforms such as Leetcode, Codewars or Hackerrank, you can go from being pretty excited to pretty down in a matter of few minutes behind a problem.

I encountered this a lot. It makes you start to question a whole lot of things, from whether it's your brain that cannot process much to whether you are not built for this field and a whole lot of other things.

But then, after spending some time questioning my skills and going back and forth between problems, it turned out that _I was not really doing some things right from the onset_ and that had to do with **the way I approached the problems** I tried to solve.

In this article, I will try and explain why certain things should be avoided or embraced as I go over the 5 steps I used to improve at solving these problems.

### 1\. Understand the problem, like seriously, take time to understand the problem

So for me, one major mistake I made was immediately starting to think about concepts to solve the problem as I read the problem. I believe this was the main ingredient in preventing me from solving these problems correctly. The reason why this is an issue is that you do not get to really get into the ins and outs of the question before you start thinking about implementation.

Note that, **understanding the question is also part of the answer**.

One time, I rushed into writing code for a problem when I had not even finished reading the problem and instead of returning an array of integers from the function, I was returning a single integer ðŸ¤¦â€â™‚ï¸. As you can tell, after countless times questioning why I was failing the test cases, it was going back to reading the problem that made me finally pass them.

As simple as a problem might be from the introductory sentences, please and please refrain from shifting focus to finding the right algorithm or data structure to use. Just take time to read and digest, before doing anything else.

### 2\. Pseudocodes and Paper Solutions Still Rock

The second thing was that I jumped into coding real quick after lazily skimming through the question. This is the biggest mistake you can ever make, once you don't understand how something should work really well or the type of inputs your function will take, you know that you are definitely doomed and you cannot really do anything tangible.

Even if you understand the problem, you should not start with coding from your computer, just try and write some pseudocode on a piece of paper or notebook you have beside you or just say your thought processes out aloud (after all, you'll do this in a real interview). This is really going to improve your overall understanding of the problem and you might catch all the edge cases that come with the problem.

With your plan in place, it's just a matter of transcribing them into code using the correct syntax. Easy Peezy :)

### 3\. Avoid Premature Optimization at all Costs

To add to my already existing stack of wrong approaches, I was also trying to code out the perfect algorithm from the start (Premature Optimization).

> Premature Optimization: Trying to improve something especially with the goal of perfecting it when it's too early to do so.

When you start writing the solution to a problem and you start thinking in this way, it becomes a big issue. So rather than moving from the ground up, you try to hit the jackpot on the first try. Everyone knows that this is rarely even the case in casinos.

The best way to start solving a problem is to start off with the most basic and unoptimized approach, what we usually call the **"Brute Force"** solution, and slowly work your way up because, at this point, you have something that solves the problem but is inefficient that you just have to transform into an efficient solution. This is in contrast to you trying to optimize something you have not even written.

### 4\. It takes time to get things right

Like it was or is in some of your university classes, it is not all the time you get a problem right on the first spot. It takes time and practice to become good at something. Don't get the wrong feeling for failing all the test cases, that is how we end up learning. As you fail these problems, you should spend some time trying to figure out what really went wrong rather than jumping into viewing the solutions that have been posted by other users. I found myself doing that and that really did not make me any better. It is much better to struggle a little bit more, if you still do not get it, you can go on and use the hints from the problem and also, log as much as possible, it is very important to know what is going on at each point in your code.

### 5\. Compare and Contrast

One of the best feelings you can get is the satisfaction of being able to solve a problem correctly. You get really excited and happy, feeling on top of the world, cool right? One thing though is that you should not jump on to the next problem but then, try to always view solutions posted by other developers on the problem. Look, you will really learn a lot by going through it.

This is really something I use to my advantage and I learn a lot of handy handy functions, methods and even parameters to some functions.

This will also make you see the thought process of others and get a complete overview of the problem from other points of view.

### To Conclude

I can assure you that fully utilizing this thought process is going to really improve how well you do in solving problems relating to DSA and programming in general. Also, do note that although it will be great to jump into practising problems on algorithms, you should make sure you have really learnt enough and mastered some very necessary foundational algorithms and data structures as these are mostly what other algorithms are based on and problems require you to understand.

**All the best in your journey ðŸŽŠ**
